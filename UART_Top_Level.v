`timescale 1ns / 1ps
//****************************************************************//
//  This document contains information proprietary to the         //
//  CSULB student that created the file - any reuse without       //
//  adequate approval and documentation is prohibited             //
//                                                                //
//  Class: CECS 460												            //
//  Project name: LAB 3												         //
//  File name: UART_Top_Level.v	                                 //
//                                                                //
//  Created by Harrison Fitch on 10/8/17.                         //
//  Copyright © 2017 Harrison Fitch. All rights reserved.         //
//                                                                //
//  Abstract: Full UART with interface to the tramelblaze 			//
//  processor. Instantiates the Receive and Transmit engines in 	//
//	 parallel with the tramelblaze. The purpose is to receive data //
//	 and process it through the tramelblaze, then output it using 	//
//	 transmit engine. This echoing process requires the flags from //
//	 both engines, the configuration bits for communication, and 	//
//	 the RX input followed by the tx_out output. LEDs are updated to 	//
//	 show the transfer while it is in progress.							//
//																						//
//  Edit history: 								 								//
//                                                                //
//  In submitting this file for class work at CSULB               //
//  I am confirming that this is my work and the work             //
//  of no one else.                                               //
//                                                                //
//  In the event other code sources are utilized I will           //
//  document which portion of code and who is the author          //
//                                                                //
// In submitting this code I acknowledge that plagiarism          //
// in student project work is subject to dismissal from the class //
//****************************************************************//
module UART_Top_Level(clk, rst, baud, eight, pen, ohel, RX, tx_out, LEDs);
	input clk, rst, eight, pen, ohel, RX;
	input	[3:0] baud;
	output tx_out;	
	output reg [7:0] LEDs;
	
	wire 			reset, UART_INT, pulse_t, pulse_r, rupt, ack;
	wire			w_s, r_s, load, txrdy;
	
	//status flags from receive ONLY
	wire [3:0]	r_status;			
	wire [7:0]	r_data, status;	
	wire [15:0] o_p, p_id;
	wire [63:0] reads, writes;
	
	reg [15:0]	UART_DS;
	reg [15:0]	out;
		
	//								 clk, 		 	  rst, 				reset
	AISO 					aiso	(.clk(clk), .rst(rst), .reset(reset));
	
	//								 clk, 			  rst,        d  ,     q
	pulse_maker_PED	txrdy_ped	(.clk(clk), .rst(reset), .d(txrdy), .q(pulse_t));
	
	//								 clk, 			  rst,        d  ,     q
	pulse_maker_PED	rxrdy_ped	(.clk(clk), .rst(reset), .d(r_status[0]), .q(pulse_r));
	
	//contains memories necessary to use the transmit engine
	tramelblaze_top	tblaze	(.CLK(clk), .RESET(reset), .IN_PORT(UART_DS), .INTERRUPT(rupt), 
										.OUT_PORT(o_p), .PORT_ID(p_id), .READ_STROBE(r_s), .WRITE_STROBE(w_s),
										.INTERRUPT_ACK(ack));

	RS_flop				rs			(.clk(clk), .rst(reset), .r(ack), .s(UART_INT), .q(rupt));
	
	address_decoder 	decoder	(.w_s(w_s), .r_s(r_s), .p_id(p_id[5:0]), .reads(reads), .writes(writes));
	
	//Transmit engine, transmit echo of receive
	Transmit_Engine 	transmit	(.clk(clk), .rst(reset), .load(load),.data(out[7:0]),
									.eight(eight), .pen(pen), .ohel(ohel), .baud(baud), .tx_outRDY(txrdy), .tx_out(tx_out));
									
	//Receive engine, receives from terminal
	Receive_Engine		receive	(.clk(clk), .rst(reset), .baud(baud), .RX(RX), .EIGHT(eight), .PEN(pen), .OHEL(ohel),
									.RX_STATUS(r_status), .R_DATA(r_data), .reads(reads));
	
	//build status flag net with assign, upper 3 bits are zeros
	//STATUS configuration 		0 = RXRDY
	//									1 = tx_outRDY
	//									2 = PERR
	//									3 = FERR
	//									4 = OVF
	assign status = {3'b0, r_status[3:1], txrdy, r_status[0]};
	
	//load data from tramelblaze
	assign load = writes[0];
	
	//interrupt signal generated by txrdy or rxrdy
	assign UART_INT = pulse_t || pulse_r;
	
	//synchronization flop
	always @(posedge clk, posedge reset)begin
		if (reset)begin
			out <= 16'b0;
			LEDs <= 8'b0;
		end
		else begin
			//LEDs output_port selection
			if(writes[4])
				LEDs <= o_p[7:0];
			out <= o_p;
		end
	end
	
	//MUX choosing between status or data
	always @(*)begin
		case (reads[1:0])
			2'b00: UART_DS = 16'b0;
			2'b01: UART_DS = r_data;
			2'b10: UART_DS = status;
			2'b11: UART_DS = 16'bx;
			default:
					 UART_DS = 16'b0;
		endcase
	end
endmodule
